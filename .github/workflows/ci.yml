name: "git action - ecr - ecs"
on:
  push:
    branches:
      - python_docker_dev  # Trigger for dev deployments
  pull_request:
    branches:
      - pythonstage  # Trigger stage deployment on PR to stage
      - pythonprod   # Trigger prod deployment on PR to prod from stage
    types: [closed]  # Only trigger after PR is merged
permissions:
      id-token: write # This is required for aws oidc connection
      contents: read # This is required for actions/checkout
env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  # ECR_REPO: ${{ secrets.ECR_REPO }}
jobs:
  deploy:
    if: github.event_name == 'push' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: .
    steps:
      - name: Git checkout
        uses: actions/checkout@v4.1.7

      - name: ☁️ Determine Environment and ECS Variables
        id: set-vars
        run: |
          BRANCH_NAME="${GITHUB_REF##*/}"

          # Push to pythondev
          if [[ "$GITHUB_EVENT_NAME" == "push" && "$BRANCH_NAME" == "python_docker_dev" ]]; then
            echo "env_path=pythondev" >> $GITHUB_OUTPUT
            echo "ecr_repo=${{ secrets.ECR_REPO }}" >> $GITHUB_OUTPUT
            echo "ecs_cluster=${{ secrets.ECS_CLUSTER_DEV }}" >> $GITHUB_OUTPUT
            echo "ecs_service=${{ secrets.ECS_SERVICE_DEV }}" >> $GITHUB_OUTPUT
            echo "container_name=${{ secrets.CONTAINER_NAME_DEV }}" >> $GITHUB_OUTPUT
            echo "role_arn=${{ secrets.AWS_DEV_GITHUB_ACTION_ROLE }}" >> $GITHUB_OUTPUT

          # PR merged to pythonstage
          elif [[ "$GITHUB_EVENT_NAME" == "pull_request" && "$BRANCH_NAME" == "pythonstage" ]]; then
            echo "env_path=pythonstage" >> $GITHUB_OUTPUT
            echo "ecr_repo=${{ secrets.ECR_REPO_STAGE }}" >> $GITHUB_OUTPUT
            echo "ecs_cluster=${{ secrets.ECS_CLUSTER_STAGE }}" >> $GITHUB_OUTPUT
            echo "ecs_service=${{ secrets.ECS_SERVICE_STAGE }}" >> $GITHUB_OUTPUT
            echo "container_name=${{ secrets.CONTAINER_NAME_STAGE }}" >> $GITHUB_OUTPUT
            echo "role_arn=${{ secrets.AWS_DEV_GITHUB_ACTION_ROLE }}" >> $GITHUB_OUTPUT

          # PR merged to pythonprod (from pythonstage)
          elif [[ "$GITHUB_EVENT_NAME" == "pull_request" && "$BRANCH_NAME" == "pythonprod" && "${{ github.event.pull_request.head.ref }}" == "pythonstage" ]]; then
            echo "env_path=pythonprod" >> $GITHUB_OUTPUT
            echo "ecr_repo=${{ secrets.ECR_REPO_PROD }}" >> $GITHUB_OUTPUT
            echo "ecs_cluster=${{ secrets.ECS_CLUSTER_PROD }}" >> $GITHUB_OUTPUT
            echo "ecs_service=${{ secrets.ECS_SERVICE_PROD }}" >> $GITHUB_OUTPUT
            echo "container_name=${{ secrets.CONTAINER_NAME_PROD }}" >> $GITHUB_OUTPUT
            echo "role_arn=${{ secrets.AWS_DEV_GITHUB_ACTION_ROLE }}" >> $GITHUB_OUTPUT

          else
            echo "❌ Unsupported branch or condition"
            exit 1
          fi

      - name: Configure AWS credentials from AWS account
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.set-vars.outputs.role_arn }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          ECR_REPO: ${{ steps.set-vars.outputs.ecr_repo }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG"
          echo "Pushing image: $IMAGE_URI"
          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      - name: 📦 Get current ECS task definition
        id: get-task-def
        run: |
          echo "Cluster: ${{ steps.set-vars.outputs.ecs_cluster }}"
          echo "Service: ${{ steps.set-vars.outputs.ecs_service }}"
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ steps.set-vars.outputs.ecs_cluster }} \
            --services ${{ steps.set-vars.outputs.ecs_service }} \
            --query "services[0].taskDefinition" \
            --output text)

          if [[ -z "$TASK_DEF_ARN" || "$TASK_DEF_ARN" == "None" ]]; then
            echo "❌ Failed to fetch ECS task definition ARN"
            exit 1
          fi
          echo "Fetched task def ARN: $TASK_DEF_ARN"
          echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV
          echo "task_def_arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: 🛠 Register new ECS task definition revision
        id: new-task-def
        run: |
          # Download current task def and replace image
          aws ecs describe-task-definition \
            --task-definition ${{ env.TASK_DEF_ARN }} \
            --query "taskDefinition" > task-def.json

          # Replace container image
          CONTAINER_NAME=${{ steps.set-vars.outputs.container_name }}
          IMAGE_URI=${{ env.IMAGE_URI }}

          jq --arg IMAGE "$IMAGE_URI" --arg NAME "$CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.status, .revision, .taskDefinitionArn, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            task-def.json > new-task-def.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)

          echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: 🚀 Update ECS Service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.set-vars.outputs.ecs_cluster }} \
            --service ${{ steps.set-vars.outputs.ecs_service }} \
            --task-definition ${{ env.NEW_TASK_DEF_ARN }} \
            --force-new-deployment

      - name: ✅ Confirm Deployment is Stable
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.set-vars.outputs.ecs_cluster }} \
            --services ${{ steps.set-vars.outputs.ecs_service }}
       
